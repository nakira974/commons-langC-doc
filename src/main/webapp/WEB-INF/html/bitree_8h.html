<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>commons-langC: C:/Users/maxim/CLionProjects/collections_commons/headers/bitree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">commons-langC<span id="projectnumber">&#160;alpha-0.1.0</span>
   </div>
   <div id="projectbrief">Provides a collection of commonly used data structures and algorithms, including linked lists,</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7f57b1e41c5acd0e859ae5f3a2b075a9.html">headers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bitree.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the API for binary search trees.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="bitree_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure definition for a binary tree node.  <a href="structBinaryTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryTree.html">BinaryTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure definition for a binary tree.  <a href="structBinaryTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aebf2348acf430af8fbdef5588daa83e7" id="r_aebf2348acf430af8fbdef5588daa83e7"><td class="memItemLeft" align="right" valign="top"><a id="aebf2348acf430af8fbdef5588daa83e7" name="aebf2348acf430af8fbdef5588daa83e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>bitree_isSymmetric</b>(tree)&#160;&#160;&#160;(bitree_isMirror((tree)-&gt;root, (tree)-&gt;root))</td></tr>
<tr class="memdesc:aebf2348acf430af8fbdef5588daa83e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates if the given tree is symmetric or not. <br /></td></tr>
<tr class="separator:aebf2348acf430af8fbdef5588daa83e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee82579480fd0e3d9d6f1f5dcc3ade8f" id="r_aee82579480fd0e3d9d6f1f5dcc3ade8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee82579480fd0e3d9d6f1f5dcc3ade8f">bitree_size</a>(tree)&#160;&#160;&#160;((tree)-&gt;size)</td></tr>
<tr class="memdesc:aee82579480fd0e3d9d6f1f5dcc3ade8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates the size of the given binary tree.  <br /></td></tr>
<tr class="separator:aee82579480fd0e3d9d6f1f5dcc3ade8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d45ad436a670d47a28c602d5f49136" id="r_ae2d45ad436a670d47a28c602d5f49136"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d45ad436a670d47a28c602d5f49136">bitree_root</a>(tree)&#160;&#160;&#160;((tree)-&gt;root)</td></tr>
<tr class="memdesc:ae2d45ad436a670d47a28c602d5f49136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates the root node of the given binary tree.  <br /></td></tr>
<tr class="separator:ae2d45ad436a670d47a28c602d5f49136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ca0b247b6cde60ff637ddab6c611d" id="r_a8b6ca0b247b6cde60ff637ddab6c611d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6ca0b247b6cde60ff637ddab6c611d">bitree_isNodeEOB</a>(node)&#160;&#160;&#160;((node) == NULL)</td></tr>
<tr class="memdesc:a8b6ca0b247b6cde60ff637ddab6c611d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates if a node is the root of its binary tree.  <br /></td></tr>
<tr class="separator:a8b6ca0b247b6cde60ff637ddab6c611d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3819d1b5ffcc12c49d10343ae46bb4" id="r_aed3819d1b5ffcc12c49d10343ae46bb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed3819d1b5ffcc12c49d10343ae46bb4">bitree_isNodeLeaf</a>(node)&#160;&#160;&#160;((node)-&gt;left == NULL (node)-&gt;right == NULL)</td></tr>
<tr class="memdesc:aed3819d1b5ffcc12c49d10343ae46bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates if a node is leaf in its tree.  <br /></td></tr>
<tr class="separator:aed3819d1b5ffcc12c49d10343ae46bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ba146437f42beccb8144fc40bb864c" id="r_a17ba146437f42beccb8144fc40bb864c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17ba146437f42beccb8144fc40bb864c">bitree_value</a>(node)&#160;&#160;&#160;((node)-&gt;value)</td></tr>
<tr class="memdesc:a17ba146437f42beccb8144fc40bb864c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates the value of a given node.  <br /></td></tr>
<tr class="separator:a17ba146437f42beccb8144fc40bb864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e38a219b30c3fe37a5886f97ee382" id="r_ad01e38a219b30c3fe37a5886f97ee382"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01e38a219b30c3fe37a5886f97ee382">bitree_left</a>(node)&#160;&#160;&#160;((node)-&gt;left)</td></tr>
<tr class="memdesc:ad01e38a219b30c3fe37a5886f97ee382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates the left child of a given node.  <br /></td></tr>
<tr class="separator:ad01e38a219b30c3fe37a5886f97ee382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65ee7ea80811e90c4b1726c7438b52f" id="r_ad65ee7ea80811e90c4b1726c7438b52f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad65ee7ea80811e90c4b1726c7438b52f">bitree_right</a>(node)&#160;&#160;&#160;((node)-&gt;left)</td></tr>
<tr class="memdesc:ad65ee7ea80811e90c4b1726c7438b52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that evaluates the right child of a given node.  <br /></td></tr>
<tr class="separator:ad65ee7ea80811e90c4b1726c7438b52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a47ea08d677e3c04e1f22de36edff6376" id="r_a47ea08d677e3c04e1f22de36edff6376"><td class="memItemLeft" align="right" valign="top"><a id="a47ea08d677e3c04e1f22de36edff6376" name="a47ea08d677e3c04e1f22de36edff6376"></a>
typedef struct BinaryTreeNode&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryTreeNode</b></td></tr>
<tr class="memdesc:a47ea08d677e3c04e1f22de36edff6376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure definition for a binary tree node. <br /></td></tr>
<tr class="separator:a47ea08d677e3c04e1f22de36edff6376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06777af06d193b303b9d45a5b13144f" id="r_ad06777af06d193b303b9d45a5b13144f"><td class="memItemLeft" align="right" valign="top"><a id="ad06777af06d193b303b9d45a5b13144f" name="ad06777af06d193b303b9d45a5b13144f"></a>
typedef struct BinaryTree&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryTree</b></td></tr>
<tr class="memdesc:ad06777af06d193b303b9d45a5b13144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure definition for a binary tree. <br /></td></tr>
<tr class="separator:ad06777af06d193b303b9d45a5b13144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a57e519f6cf3e5bfa9eb427761fd31dcb" id="r_a57e519f6cf3e5bfa9eb427761fd31dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57e519f6cf3e5bfa9eb427761fd31dcb">bitree_create</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, void(*destroy)(void *value))</td></tr>
<tr class="memdesc:a57e519f6cf3e5bfa9eb427761fd31dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a given binary tree with default values.  <br /></td></tr>
<tr class="separator:a57e519f6cf3e5bfa9eb427761fd31dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92731a77b37bc54c1ee4240fcf01ef99" id="r_a92731a77b37bc54c1ee4240fcf01ef99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92731a77b37bc54c1ee4240fcf01ef99">bitree_destroy</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree)</td></tr>
<tr class="memdesc:a92731a77b37bc54c1ee4240fcf01ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and clean memory of a given binary tree.  <br /></td></tr>
<tr class="separator:a92731a77b37bc54c1ee4240fcf01ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c298a758a8db51599b4ed0d02b8b49d" id="r_a8c298a758a8db51599b4ed0d02b8b49d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c298a758a8db51599b4ed0d02b8b49d">bitree_addLeft</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *node, const void *value)</td></tr>
<tr class="memdesc:a8c298a758a8db51599b4ed0d02b8b49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to create a new left child node of the given node in the given tree.  <br /></td></tr>
<tr class="separator:a8c298a758a8db51599b4ed0d02b8b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004e033b8eb8fb2447f088571edd2f34" id="r_a004e033b8eb8fb2447f088571edd2f34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a004e033b8eb8fb2447f088571edd2f34">bitree_addRight</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *node, const void *value)</td></tr>
<tr class="memdesc:a004e033b8eb8fb2447f088571edd2f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to create a new right child node of the given node in the given tree.  <br /></td></tr>
<tr class="separator:a004e033b8eb8fb2447f088571edd2f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e181943c8b8a03b27e8a89e75fcc5ae" id="r_a4e181943c8b8a03b27e8a89e75fcc5ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e181943c8b8a03b27e8a89e75fcc5ae">bitree_removeLeft</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *node)</td></tr>
<tr class="memdesc:a4e181943c8b8a03b27e8a89e75fcc5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the left child of the given node in the given binary tree.  <br /></td></tr>
<tr class="separator:a4e181943c8b8a03b27e8a89e75fcc5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8bd2d7475f45c6e7637a657814739e" id="r_a1b8bd2d7475f45c6e7637a657814739e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b8bd2d7475f45c6e7637a657814739e">bitree_removeRight</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *node)</td></tr>
<tr class="memdesc:a1b8bd2d7475f45c6e7637a657814739e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the right child of the given node in the given binary tree.  <br /></td></tr>
<tr class="separator:a1b8bd2d7475f45c6e7637a657814739e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab82525c0b7a8b4c80176ccfe158097" id="r_a0ab82525c0b7a8b4c80176ccfe158097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ab82525c0b7a8b4c80176ccfe158097">bitree_merge</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *out, <a class="el" href="structBinaryTree.html">BinaryTree</a> *left, <a class="el" href="structBinaryTree.html">BinaryTree</a> *right, const void *value)</td></tr>
<tr class="memdesc:a0ab82525c0b7a8b4c80176ccfe158097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the left and right binary tress into out where value will be set as root's value.  <br /></td></tr>
<tr class="separator:a0ab82525c0b7a8b4c80176ccfe158097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e0de8b0ac74f88de8d262a04d868f" id="r_a5f5e0de8b0ac74f88de8d262a04d868f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f5e0de8b0ac74f88de8d262a04d868f">bitree_maxDepth</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree)</td></tr>
<tr class="memdesc:a5f5e0de8b0ac74f88de8d262a04d868f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum depth of the given binary tree.  <br /></td></tr>
<tr class="separator:a5f5e0de8b0ac74f88de8d262a04d868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f6c544cd95cf9542732c50942c880b" id="r_a17f6c544cd95cf9542732c50942c880b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17f6c544cd95cf9542732c50942c880b">bitree_maxDepthBranch</a> (<a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *branchRoot)</td></tr>
<tr class="memdesc:a17f6c544cd95cf9542732c50942c880b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum depth of the given binary tree.  <br /></td></tr>
<tr class="separator:a17f6c544cd95cf9542732c50942c880b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1cac24ac28e329b0db3bc1dafb62a" id="r_ab2d1cac24ac28e329b0db3bc1dafb62a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d1cac24ac28e329b0db3bc1dafb62a">bitree_isSameTree</a> (bool(*equals)(const void *value1, const void *value2), <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *left, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *right)</td></tr>
<tr class="memdesc:ab2d1cac24ac28e329b0db3bc1dafb62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two nodes are in the same binary tree or not.  <br /></td></tr>
<tr class="separator:ab2d1cac24ac28e329b0db3bc1dafb62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ad653321f6ee27f7426de5feeb05d" id="r_aa46ad653321f6ee27f7426de5feeb05d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46ad653321f6ee27f7426de5feeb05d">bitree_invert</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *out, <a class="el" href="structBinaryTree.html">BinaryTree</a> *tree)</td></tr>
<tr class="memdesc:aa46ad653321f6ee27f7426de5feeb05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given binary tree.  <br /></td></tr>
<tr class="separator:aa46ad653321f6ee27f7426de5feeb05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56926892a37878d222ff881c4ed37dbe" id="r_a56926892a37878d222ff881c4ed37dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56926892a37878d222ff881c4ed37dbe">bitree_invertBranch</a> (<a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *branchRoot)</td></tr>
<tr class="memdesc:a56926892a37878d222ff881c4ed37dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the current branch starting from the given node.  <br /></td></tr>
<tr class="separator:a56926892a37878d222ff881c4ed37dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ccea07d8ca3d364ed521a9b6a5f4da" id="r_af3ccea07d8ca3d364ed521a9b6a5f4da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3ccea07d8ca3d364ed521a9b6a5f4da">bitree_isMirror</a> (bool(*equals)(const void *value1, const void *value2), <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *left, <a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *right)</td></tr>
<tr class="memdesc:af3ccea07d8ca3d364ed521a9b6a5f4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two nodes are symmetric or not.  <br /></td></tr>
<tr class="separator:af3ccea07d8ca3d364ed521a9b6a5f4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e0255107fea81ce552083b6b80ca4" id="r_a164e0255107fea81ce552083b6b80ca4"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164e0255107fea81ce552083b6b80ca4">bitree_levelOrder</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree, int *returnSize, int **returnColumnSizes)</td></tr>
<tr class="memdesc:a164e0255107fea81ce552083b6b80ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a binary tree by level.  <br /></td></tr>
<tr class="separator:a164e0255107fea81ce552083b6b80ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0aa9e2e06b28608e993f512e8c903" id="r_a41b0aa9e2e06b28608e993f512e8c903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41b0aa9e2e06b28608e993f512e8c903">bitree_build_from_preorder_inorder_branch</a> (void **preorder, int preorder_size, void **inorder, int inorder_size, bool(*equals)(const void *value1, const void *value2))</td></tr>
<tr class="memdesc:a41b0aa9e2e06b28608e993f512e8c903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary tree from preorder and inorder traversal.  <br /></td></tr>
<tr class="separator:a41b0aa9e2e06b28608e993f512e8c903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffb820caad19a2607cfa6ca8cdd4738" id="r_a3ffb820caad19a2607cfa6ca8cdd4738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ffb820caad19a2607cfa6ca8cdd4738">bitree_build_from_inorder_postorder_branch</a> (void **inorder, int inorderSize, int **postorder, int postorderSize, bool(*equals)(const void *value1, const void *value2))</td></tr>
<tr class="memdesc:a3ffb820caad19a2607cfa6ca8cdd4738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary tree from inorder and postorder traversal.  <br /></td></tr>
<tr class="separator:a3ffb820caad19a2607cfa6ca8cdd4738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6aa396cf0f50a8168c1a87df81b1575" id="r_aa6aa396cf0f50a8168c1a87df81b1575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBinaryTree.html">BinaryTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6aa396cf0f50a8168c1a87df81b1575">bitree_build_from_preorder_inorder</a> (void **preorder, int preorder_size, void **inorder, int inorder_size, void(*destroy)(void *value), bool(*equals)(const void *value1, const void *value2))</td></tr>
<tr class="memdesc:aa6aa396cf0f50a8168c1a87df81b1575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary tree from preorder and inorder traversal.  <br /></td></tr>
<tr class="separator:aa6aa396cf0f50a8168c1a87df81b1575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0696ba247867d48d9fc7dee45f822fb" id="r_ae0696ba247867d48d9fc7dee45f822fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBinaryTree.html">BinaryTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0696ba247867d48d9fc7dee45f822fb">bitree_build_from_inorder_postorder</a> (void **inorder, int inorderSize, int **postorder, int postorderSize, void(*destroy)(void *value), bool(*equals)(const void *value1, const void *value2))</td></tr>
<tr class="memdesc:ae0696ba247867d48d9fc7dee45f822fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary tree from inorder and postorder traversal.  <br /></td></tr>
<tr class="separator:ae0696ba247867d48d9fc7dee45f822fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8c6408d68dd9db15e6ae37969a756" id="r_ab2b8c6408d68dd9db15e6ae37969a756"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b8c6408d68dd9db15e6ae37969a756">bitree_height</a> (<a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *root, int *diameter)</td></tr>
<tr class="memdesc:ab2b8c6408d68dd9db15e6ae37969a756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the longest path length in the given branch.  <br /></td></tr>
<tr class="separator:ab2b8c6408d68dd9db15e6ae37969a756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2fdf9142f1d150f76817949cd4dc8d" id="r_ace2fdf9142f1d150f76817949cd4dc8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace2fdf9142f1d150f76817949cd4dc8d">bitree_diameter</a> (<a class="el" href="structBinaryTree.html">BinaryTree</a> *tree)</td></tr>
<tr class="memdesc:ace2fdf9142f1d150f76817949cd4dc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the longest path length in the given binary tree.  <br /></td></tr>
<tr class="separator:ace2fdf9142f1d150f76817949cd4dc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the API for binary search trees. </p>
<p>This file contains the API for balanced trees.</p>
<p>This file contains the API for binary trees.</p>
<dl class="section author"><dt>Author</dt><dd>Maxime Loukhal </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/03/2024</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Maxime Loukhal </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/03/2024 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8b6ca0b247b6cde60ff637ddab6c611d" name="a8b6ca0b247b6cde60ff637ddab6c611d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6ca0b247b6cde60ff637ddab6c611d">&#9670;&#160;</a></span>bitree_isNodeEOB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_isNodeEOB</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">node</span></td><td>)</td>
          <td>&#160;&#160;&#160;((node) == NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates if a node is the root of its binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to determine if it's a root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given node is the root of its binary tree, false otherwise </dd></dl>

</div>
</div>
<a id="aed3819d1b5ffcc12c49d10343ae46bb4" name="aed3819d1b5ffcc12c49d10343ae46bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3819d1b5ffcc12c49d10343ae46bb4">&#9670;&#160;</a></span>bitree_isNodeLeaf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_isNodeLeaf</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">node</span></td><td>)</td>
          <td>&#160;&#160;&#160;((node)-&gt;left == NULL (node)-&gt;right == NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates if a node is leaf in its tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to determine if it's a leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if is the given node is a leaf, false otherwise </dd></dl>

</div>
</div>
<a id="ad01e38a219b30c3fe37a5886f97ee382" name="ad01e38a219b30c3fe37a5886f97ee382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e38a219b30c3fe37a5886f97ee382">&#9670;&#160;</a></span>bitree_left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_left</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">node</span></td><td>)</td>
          <td>&#160;&#160;&#160;((node)-&gt;left)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates the left child of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to return the left child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left child of the given node </dd></dl>

</div>
</div>
<a id="ad65ee7ea80811e90c4b1726c7438b52f" name="ad65ee7ea80811e90c4b1726c7438b52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65ee7ea80811e90c4b1726c7438b52f">&#9670;&#160;</a></span>bitree_right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_right</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">node</span></td><td>)</td>
          <td>&#160;&#160;&#160;((node)-&gt;left)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates the right child of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to return the right child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right child of the given node </dd></dl>

</div>
</div>
<a id="ae2d45ad436a670d47a28c602d5f49136" name="ae2d45ad436a670d47a28c602d5f49136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d45ad436a670d47a28c602d5f49136">&#9670;&#160;</a></span>bitree_root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_root</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">tree</span></td><td>)</td>
          <td>&#160;&#160;&#160;((tree)-&gt;root)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates the root node of the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree to get the root node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current root node of the given binary tree </dd></dl>

</div>
</div>
<a id="aee82579480fd0e3d9d6f1f5dcc3ade8f" name="aee82579480fd0e3d9d6f1f5dcc3ade8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee82579480fd0e3d9d6f1f5dcc3ade8f">&#9670;&#160;</a></span>bitree_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_size</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">tree</span></td><td>)</td>
          <td>&#160;&#160;&#160;((tree)-&gt;size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates the size of the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree to get the size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current size of the given binary tree </dd></dl>

</div>
</div>
<a id="a17ba146437f42beccb8144fc40bb864c" name="a17ba146437f42beccb8144fc40bb864c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ba146437f42beccb8144fc40bb864c">&#9670;&#160;</a></span>bitree_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitree_value</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">node</span></td><td>)</td>
          <td>&#160;&#160;&#160;((node)-&gt;value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that evaluates the value of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to return the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the given node </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8c298a758a8db51599b4ed0d02b8b49d" name="a8c298a758a8db51599b4ed0d02b8b49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c298a758a8db51599b4ed0d02b8b49d">&#9670;&#160;</a></span>bitree_addLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_addLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to create a new left child node of the given node in the given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to add a left node </td></tr>
    <tr><td class="paramname">node</td><td>Node to add a left child </td></tr>
    <tr><td class="paramname">value</td><td>Value to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the left node was created, false otherwise </dd></dl>

</div>
</div>
<a id="a004e033b8eb8fb2447f088571edd2f34" name="a004e033b8eb8fb2447f088571edd2f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004e033b8eb8fb2447f088571edd2f34">&#9670;&#160;</a></span>bitree_addRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_addRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to create a new right child node of the given node in the given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to add a right node </td></tr>
    <tr><td class="paramname">node</td><td>Node to add a right child </td></tr>
    <tr><td class="paramname">value</td><td>Value to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the right node was created, false otherwise </dd></dl>

</div>
</div>
<a id="ae0696ba247867d48d9fc7dee45f822fb" name="ae0696ba247867d48d9fc7dee45f822fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0696ba247867d48d9fc7dee45f822fb">&#9670;&#160;</a></span>bitree_build_from_inorder_postorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryTree.html">BinaryTree</a> * bitree_build_from_inorder_postorder </td>
          <td>(</td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>inorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inorderSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>postorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>postorderSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *value)</td>          <td class="paramname"><span class="paramname"><em>destroy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a binary tree from inorder and postorder traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inorder</td><td>An array representing the inorder traversal of the tree. </td></tr>
    <tr><td class="paramname">inorderSize</td><td>The size of the inorder array. </td></tr>
    <tr><td class="paramname">postorder</td><td>An array representing the postorder traversal of the tree. </td></tr>
    <tr><td class="paramname">postorderSize</td><td>The size of the postorder array. </td></tr>
    <tr><td class="paramname">destroy</td><td>The destroy function of the created binary tree </td></tr>
    <tr><td class="paramname">equals</td><td>Node value equals function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the constructed binary tree. </dd></dl>

</div>
</div>
<a id="a3ffb820caad19a2607cfa6ca8cdd4738" name="a3ffb820caad19a2607cfa6ca8cdd4738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffb820caad19a2607cfa6ca8cdd4738">&#9670;&#160;</a></span>bitree_build_from_inorder_postorder_branch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> * bitree_build_from_inorder_postorder_branch </td>
          <td>(</td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>inorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inorderSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>postorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>postorderSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a binary tree from inorder and postorder traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inorder</td><td>An array representing the inorder traversal of the tree. </td></tr>
    <tr><td class="paramname">inorderSize</td><td>The size of the inorder array. </td></tr>
    <tr><td class="paramname">postorder</td><td>An array representing the postorder traversal of the tree. </td></tr>
    <tr><td class="paramname">postorderSize</td><td>The size of the postorder array. </td></tr>
    <tr><td class="paramname">equals</td><td>Node value equals function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the constructed binary tree. </dd></dl>

</div>
</div>
<a id="aa6aa396cf0f50a8168c1a87df81b1575" name="aa6aa396cf0f50a8168c1a87df81b1575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6aa396cf0f50a8168c1a87df81b1575">&#9670;&#160;</a></span>bitree_build_from_preorder_inorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryTree.html">BinaryTree</a> * bitree_build_from_preorder_inorder </td>
          <td>(</td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>preorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>preorder_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>inorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inorder_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *value)</td>          <td class="paramname"><span class="paramname"><em>destroy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a binary tree from preorder and inorder traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preorder</td><td>An array representing the preorder traversal of the tree. </td></tr>
    <tr><td class="paramname">preorder_size</td><td>The size of the preorder array. </td></tr>
    <tr><td class="paramname">inorder</td><td>An array representing the inorder traversal of the tree. </td></tr>
    <tr><td class="paramname">inorder_size</td><td>The size of the inorder array. </td></tr>
    <tr><td class="paramname">destroy</td><td>The destroy function of the created binary tree </td></tr>
    <tr><td class="paramname">equals</td><td>Node value equals function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the constructed binary tree. </dd></dl>

</div>
</div>
<a id="a41b0aa9e2e06b28608e993f512e8c903" name="a41b0aa9e2e06b28608e993f512e8c903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b0aa9e2e06b28608e993f512e8c903">&#9670;&#160;</a></span>bitree_build_from_preorder_inorder_branch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> * bitree_build_from_preorder_inorder_branch </td>
          <td>(</td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>preorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>preorder_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>inorder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inorder_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a binary tree from preorder and inorder traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preorder</td><td>An array representing the preorder traversal of the tree. </td></tr>
    <tr><td class="paramname">preorder_size</td><td>The size of the preorder array. </td></tr>
    <tr><td class="paramname">inorder</td><td>An array representing the inorder traversal of the tree. </td></tr>
    <tr><td class="paramname">inorder_size</td><td>The size of the inorder array. </td></tr>
    <tr><td class="paramname">equals</td><td>Node value equals function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the constructed binary tree. </dd></dl>

</div>
</div>
<a id="a57e519f6cf3e5bfa9eb427761fd31dcb" name="a57e519f6cf3e5bfa9eb427761fd31dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e519f6cf3e5bfa9eb427761fd31dcb">&#9670;&#160;</a></span>bitree_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitree_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *value)</td>          <td class="paramname"><span class="paramname"><em>destroy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a given binary tree with default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to be created </td></tr>
    <tr><td class="paramname">destroy</td><td>Destroy user handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92731a77b37bc54c1ee4240fcf01ef99" name="a92731a77b37bc54c1ee4240fcf01ef99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92731a77b37bc54c1ee4240fcf01ef99">&#9670;&#160;</a></span>bitree_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitree_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys and clean memory of a given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace2fdf9142f1d150f76817949cd4dc8d" name="ace2fdf9142f1d150f76817949cd4dc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2fdf9142f1d150f76817949cd4dc8d">&#9670;&#160;</a></span>bitree_diameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bitree_diameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the longest path length in the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to get the longest path on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The longest path length of the given binary tree </dd></dl>

</div>
</div>
<a id="ab2b8c6408d68dd9db15e6ae37969a756" name="ab2b8c6408d68dd9db15e6ae37969a756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b8c6408d68dd9db15e6ae37969a756">&#9670;&#160;</a></span>bitree_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bitree_height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>diameter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the longest path length in the given branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the given branch to find longest path </td></tr>
    <tr><td class="paramname">diameter</td><td>Pointer to the returned longest path length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa46ad653321f6ee27f7426de5feeb05d" name="aa46ad653321f6ee27f7426de5feeb05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46ad653321f6ee27f7426de5feeb05d">&#9670;&#160;</a></span>bitree_invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Inverted binary tree </td></tr>
    <tr><td class="paramname">tree</td><td>Binary tree to invert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56926892a37878d222ff881c4ed37dbe" name="a56926892a37878d222ff881c4ed37dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56926892a37878d222ff881c4ed37dbe">&#9670;&#160;</a></span>bitree_invertBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> * bitree_invertBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>branchRoot</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the current branch starting from the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchRoot</td><td>Relative branchRoot where to start to invert the binary tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reversed branch </dd></dl>

</div>
</div>
<a id="af3ccea07d8ca3d364ed521a9b6a5f4da" name="af3ccea07d8ca3d364ed521a9b6a5f4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ccea07d8ca3d364ed521a9b6a5f4da">&#9670;&#160;</a></span>bitree_isMirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_isMirror </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two nodes are symmetric or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equals</td><td>Nodes value compare function, usefully used to add some other nodes comparer </td></tr>
    <tr><td class="paramname">left</td><td>Left node to be compared </td></tr>
    <tr><td class="paramname">right</td><td>Right node to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if given nodes are symmetric, false otherwise </dd></dl>

</div>
</div>
<a id="ab2d1cac24ac28e329b0db3bc1dafb62a" name="ab2d1cac24ac28e329b0db3bc1dafb62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d1cac24ac28e329b0db3bc1dafb62a">&#9670;&#160;</a></span>bitree_isSameTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_isSameTree </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const void *value1, const void *value2)</td>          <td class="paramname"><span class="paramname"><em>equals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two nodes are in the same binary tree or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equals</td><td>Node compare function </td></tr>
    <tr><td class="paramname">left</td><td>Left node to be compared </td></tr>
    <tr><td class="paramname">right</td><td>Right node to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if two nodes are in the same tree, false otherwise </dd></dl>

</div>
</div>
<a id="a164e0255107fea81ce552083b6b80ca4" name="a164e0255107fea81ce552083b6b80ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e0255107fea81ce552083b6b80ca4">&#9670;&#160;</a></span>bitree_levelOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ** bitree_levelOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>returnSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>returnColumnSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a binary tree by level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to return as an array of arrays </td></tr>
    <tr><td class="paramname">returnSize</td><td>Number of levels in the binary tree </td></tr>
    <tr><td class="paramname">returnColumnSizes</td><td>Number of elements per level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of values per level in the given binary tree </dd></dl>

</div>
</div>
<a id="a5f5e0de8b0ac74f88de8d262a04d868f" name="a5f5e0de8b0ac74f88de8d262a04d868f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5e0de8b0ac74f88de8d262a04d868f">&#9670;&#160;</a></span>bitree_maxDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bitree_maxDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current maximum depth of the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree to get the maximum depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum depth of the given binary tree </dd></dl>

</div>
</div>
<a id="a17f6c544cd95cf9542732c50942c880b" name="a17f6c544cd95cf9542732c50942c880b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f6c544cd95cf9542732c50942c880b">&#9670;&#160;</a></span>bitree_maxDepthBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bitree_maxDepthBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>branchRoot</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current maximum depth of the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree to get the maximum depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum depth of the given binary tree </dd></dl>

</div>
</div>
<a id="a0ab82525c0b7a8b4c80176ccfe158097" name="a0ab82525c0b7a8b4c80176ccfe158097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab82525c0b7a8b4c80176ccfe158097">&#9670;&#160;</a></span>bitree_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bitree_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the left and right binary tress into out where value will be set as root's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output tree after tree merge operation </td></tr>
    <tr><td class="paramname">left</td><td>Left binary tree to be merged </td></tr>
    <tr><td class="paramname">right</td><td>Right binary tree to be merged </td></tr>
    <tr><td class="paramname">value</td><td>Value to be designated as out root's node value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e181943c8b8a03b27e8a89e75fcc5ae" name="a4e181943c8b8a03b27e8a89e75fcc5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e181943c8b8a03b27e8a89e75fcc5ae">&#9670;&#160;</a></span>bitree_removeLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitree_removeLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the left child of the given node in the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree where to remove the left node's value </td></tr>
    <tr><td class="paramname">node</td><td>Node to remove the left child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8bd2d7475f45c6e7637a657814739e" name="a1b8bd2d7475f45c6e7637a657814739e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8bd2d7475f45c6e7637a657814739e">&#9670;&#160;</a></span>bitree_removeRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitree_removeRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBinaryTree.html">BinaryTree</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryTreeNode.html">BinaryTreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the right child of the given node in the given binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Binary tree where to remove the right node's value </td></tr>
    <tr><td class="paramname">node</td><td>Node to remove the right child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
